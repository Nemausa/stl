#pragma once

#include <istream>
using namespace std;
#include "women.h"
#include "men.h"
#include "human.h"


namespace derived_
{

    void main()
    {
    
        // 一：派生类对象模型简述
        // Men men;  // 子类包含多个组成部分
        // (1)一个是含有派生类自己定义的成员变量，成员函数
        // (2)一个是该派生类所继承的基类的子对象，这个子对象中包含的是基类中定义的成员变量，成员函数。(派生类对象含有基类对应的组成部分)
        //Human *phuman = new Men; //基类指针可以new派生类对象，因为派生类对象含有基类部分，所以我们是可以把派生类对象当做基类对象使用的。
        // 换句话说我们可以用基类指针new一个派生类对象，编译器帮助我们做了隐式的这种派生类到基类的转换
        // 这种转换的好处就是有些需要基类引用的地方你可以用这个派生类对象的引用代替

        // 二：派生类构造函数
        // 派生类实际是使用基类的构造函数来初始化它的基类部分，派生类控制派生类部分成员的初始化
        // 既调用基类构造函数，又调用派生类构造函数
        // 传递参数给基类构造函数问题，通过派生类的构造函数初始化列表;
        // 先执行基类的构造函数，再执行派生类的构造函数
        // 先执行派生类的析构函数，再执行基类的析构函数

        // 三：既当父类又当子类

        // 四：不想当基类的类
        // final,加在类名后面，则有这个关键字的类不能做基类

        // 五：静态类型与动态类型
        //Human *phuman = new Men();  // 基类指针指向一个派生类对象
        //Human &q = *phuman;  // 基类引用绑定到派生类对象上

        // 静态类型：变量声明的时候的类型，静态类型编译的时候是已知的。
        // 动态类型：指的是这个指针/引用所代表内存中对象的类型，
        // 动态类型是在运行的时候才知道，只有基类指针/引用才存在这种静态类型和动态类型不一致的情况。
        // 如果不是基类的指针/引用，那么静态类型和动态了下永远都是一致的。

        // 六：派生类向基类的隐式类型转换
        //Human *phuman = new Men();  // 基类指针指向一个派生类对象
       // Human &q = *phuman;  // 基类引用绑定到派生类对象上
        // 编译器隐式帮我们执行了派生类到基类的转换。
        // 这种转换之所以能成功，是因为每个派生类对象都包含一个基类对象部分，所以基类的引用或者指针是可以得到基类对象的部分。
        // 基类对象能独立存在，也能作为派生类对象的一部分存在。
        // 不存在从基类到派生类的自动类型转换。
      /*  Men men;
        Human *phuman = &men;*/
        //Men *pmen = phuman;  // 不可以，编译器通过静态类型推断转换的合法性。发现基类不能转换成派生类

        // 七：父类子类对象之间的拷贝与赋值
        // 用派生类对象为一个基类对象初始化或者赋值时，只有该派生类对象的基类部分会被拷贝或者赋值，派生类部分将会被忽略。
        // 基类值操作基类的部分。
    }
}
