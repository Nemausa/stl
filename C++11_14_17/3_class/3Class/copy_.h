#pragma once
#include "time.h"
#include <iostream>
using namespace std;

namespace copy_
{
    void func(Time t)
    {

    }

    Time func2()
    {
        Time t;
        return t;  // 系统产生了临时对象并且调用了类的拷贝构造函数。
    }
    int main()
    {
        // 一：拷贝构造函数(赋值构造函数)
        // 默认情况下，类对象的拷贝是每个成员变量逐个拷贝；
        // 如果一个类的构造函数的第一个参数是所属的类类型的引用，如果还有其他额外的参数，
        // 那么这些额外的参数还有默认值,函数的默认参数必须放在函数的声明中，除非没有函数声明。
        // 拷贝构造函数的作用：会在一定的时机，被系统自动调用。
        // (1)建议拷贝构造函数第一个参数总是带const
        // (2)explicit：拷贝构造函数不能声明成explicit。

        // 成员变量逐个拷贝的功能因为我们自己定义的拷贝构造函数的存在而丢失了作用，或者
        // 说我们自己的拷贝构造函数取代了系统默认的每个成员变量逐个拷贝的行为。

        // (a)如果没有为类定义一个拷贝构造函数，编译器就会帮我们定义一个"合成拷贝构造函数"。
        // (b)
        // 每个成员的类型决定了它如何拷贝，比如说成员变量是整型，那么直接把值拷贝过来，
        // 如果成员变量时类类型，那么就会调用这个类的拷贝构造函数来拷贝。
        // (c)如果自己定义了拷贝构造函数，那么就取代了系统合成的拷贝构造函数，这个时候，
        // 你就必须要在你自己的拷贝构造函数中给类成员赋值，以免类成员变量没有赋值就被使用的情况。

        // 还有一些情况会调用拷贝构造函数情况
        // (1)将一个对象作为实参传递一个非引用类型的形参
        // (2)从一个函数中返回一个对象的时候。
        // (3)还有一些其他的情况。

        Time t;  // 调用默认的构造函数，不带参数
        Time t2 = t;  // 调用了拷贝构造函数
        //Time t3(t);   // 调用了拷贝构造函数
        //Time t4{ t };   // 调用了拷贝构造函数
        //Time t5 = { t };   // 调用了拷贝构造函数
        //Time t6;  // 调用了默认构造函数
        //t6 = t5;

        //func(t);
        //Time tf = func2();

        return 0;
    }

}