//////////////////////////////////////////////////////////////////////////
//  @file     class.h
//  @author   Morris
//  @date     2019-03-18
//  @mail     tappanmorris@outlook.com
//
//  @version  2019-03-18
//  -added 
//  @remark   类模板定义与使用 
//  @note
//////////////////////////////////////////////////////////////////////////

#ifndef  CLASS_H
#define  CLASS_H

#include "myvector.h"
#include "myarray.h"
namespace class_
{
    int main()
    {

        // 一：概述 用类模板来实例化一个特定的类
        // 编译器不能为类模板推断参数类型，所以为了使用类模板，我么必须在类模板名后边用<>来提供额外的信息，这些信息就是对应模板参数泪飚里面的这些参数。
        // 实现同一套代码可以应付不同的数据类型

        // 二：类模板定义
        // template<typename 形参1，typename 形参2>
        // 实例化类模板的时候，必须要有类的全部信息，包括类模板中成员函数的函数体
        // 所以，一个实例化了的类型总会用<>包含模板参数
        myvector<int> v_int;

        // 三：类模板的成员函数
        // 类模板成员函数，可以写在类模板定义中，那么这种写在类模板定义的成员函数会被隐式声明为inline函数
        // 类模板一旦被实例化之后，那么每个模板的每个实例都会有自己版本的成员函数。
        // 所以 类模板的成员函数具有和这个类模板相同的模板参数(这句话的核心意思：类模板的成员函数是有模板参数的)
        // 如果你要把类模板成员函数的定义(函数体)写在类模板定义的外边，那么这个成员函数的模板参数就体现出来了。
        // 定义在类模板之外的成员函数必须以template关键字开始，后面接类模板参数列表
        // 同时，在类名后面要用<>把模板参数列表里面的所有以后的模板参数名列出来，如果多个模板参数 用,分隔 
        // 一个类模板虽然可能有很多成员函数，但是，当你实例化模板之后，如果你后续没有使用到某个成员函数的话，则这个成员函数不会被实例化
        // 说白了，一个实例化的模板，它的成员函数只有在使用的时候才会被实例化


        // 四：模板类名字的使用
        // 五：非类型模板参数
        // 非类型模板参数也是有限制的
        // (1)浮点型不能作为非类型模板参数 比如float double
        // (2)类类型也是不行的

        myarray<int, 100> array1;
        array1.myfunc();
        myarray<int> array2;
        array2.myfunc();
        return 0;
    
    }


}


#endif