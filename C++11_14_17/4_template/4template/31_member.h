//////////////////////////////////////////////////////////////////////////
//  @file     member.h
//  @author   Morris
//  @date     2019-0317
//  @mail     tappanmorris@outlook.com
//
//  @version  2019-0317
//  -added 
//  @remark   成员函数模板
//  @note
//////////////////////////////////////////////////////////////////////////

#ifndef ADD_H
#define ADD_H

#include <iostream>
using namespace std;
#include "ca.h"

// 显示实例化  手段中的 实例化声明
extern template A<float>;  // 其他的所有.cpp文件中都这么写
extern template void myfunc(int v1, int v2);  

// extern作用：不会再文件中生成一个extern后面所表示的模板的实例化版本的代码
// extern目的：告诉编译器，其他的源文件中已经有了一个该模板的实例化版本了


namespace member
{
    int main()
    {
        // 一：普通类的成员函数模板
        // 不管是普通类还是类模板，它的成员函数都可以是个函数模板，成为"成员函数模板",不可以是虚函数，否则编译器会报错。
        //A a;
        //a.myft(3);  // 编译器在遇到这条语句时，编译就会实例化这个函数模板

        // 二：类模板的成员函数模板
        // 类模板的模板参数必须用<>指定，成员函数模板的参数可以推断
        // 类模板的成员函数吱哟为程序所用的时候才会进行实例化
        // 如果某函数从未使用，则不会实例化该成员函数
        A<float>a(1, 2);


        // 三：模板显示实例化，模板声明
        // 为了防止在多个.cpp文件中都实例化相同的类模板，所以C++11提出了一种解决方法，我们称为"显示实例化"
        // 通过显示实例化来避免生成多个相同类模板实例的开销

        // 模板的实例定义只有一个，声明可以有多个

        return 0;
    }
}




#endif